[Deploying a faucet](faucet.md)

# Interacting with the faucet contract

## Invoking `getBalance()`
Let's start by invoking `getBalance()`. It is an idempotent operation that will not cost us any gas:


```javascript
> instance.getBalance()
1000000000000000000
```

Since the implementation of `getBalance()` is 

```solidity
function getBalance() public view returns (uint) {
    return address(this).balance;
}
```

the returned value must be the same of `eth.getBalance(address)`:

```javascript
> instance.getBalance()
1000000000000000000
> eth.getBalance(instance.address)
1000000000000000000
```

Surprisingly:

```javascript
> eth.getBalance(instance.address) == instance.getBalance()
false
```

How could it be? It sounds like a type conversion issue, since:

```javascript
> eth.getBalance(instance.address) + 0 == instance.getBalance() + 0
true
```

The real reason is another one: both `instance.getBalance()` and `eth.getBalance()` return a `BigNumber`, since [Javascript cannot handle the large numbers needed by Ethereum](https://github.com/ethereum/wiki/wiki/JavaScript-API#a-note-on-big-numbers-in-web3js):

```javascript
> typeof instance.getBalance()
"object"
> new BigNumber(instance.getBalance())
1000000000000000000
```

So, if we need to compare the 2 balances, we must use:

```javascript
> new BigNumber(eth.getBalance(instance.address)).equals(new BigNumber(instance.getBalance()))
true
```

## Invoking methods
In general, there are 2 very different ways to invoke a method:

* with a local call, by directly invoking the method or running `someMethod.call()`;
* through a transaction.

The difference is particularly important for methods that modify the contract state.

### Local calls
Local calls are read-only: they cannot change the state of the contract instance. They are like a dry-run execution.

They don't consume any Ether.  Since they are not broadcasted to the network, they are executed synchronously.

When a method is invoked as a local call, the parameters are the ones specified by the signature in the Solidity source code

### Invocation through a transaction
On the contrary, invokations through a transactions are broadcast to the network, processed by one miner and, if valid, included in a block.<br/>
For this reason they are executed asynchronously, and the immediate return value is not the function's result but a transaction hash.

The parameters are the ones specified in the signature of the Solidity source code, plus a Transaction Parameter Object

## Using the faucet to send money to an account

```javascript
> eth.accounts
["0x8b52f87a9dc74c90d31ca5596464db452bb0b55a", "0xaddd74744dc8e1f03955398769b1ace793960141"]
> web3.fromWei(eth.getBalance(eth.accounts[0]), "ether")
53
> web3.fromWei(eth.getBalance(eth.accounts[1]), "ether")
0
```

Account 1 is broke. Let it ask for some money, invoking the method `withdrawWei()` through a transaction:

```javascript
> instance.withdrawWei({from: eth.accounts[1]})
Error: insufficient funds for gas * price + value
    at web3.js:3143:20
    at web3.js:6347:15
    at web3.js:5081:36
    at web3.js:4137:16
    at apply (<native code>)
    at web3.js:4223:16
    at <anonymous>:1:1
```

This makes sense: in order to emit a transaction, some gas must be spent.<br/>
Let's use the account 0 to send money to account 1:

```javascript
> var transaction = instance.sendWei(eth.accounts[1], {from: eth.accounts[0]})
undefined
> transaction
"0x594ae7ab20cee6b54eb2b998b2535876149fe66fa342b92dedbb948b045f329e"
> txpool.status.pending
1
> miner.start()
null
> miner.stop()
null
> txpool.status.pending
0
> web3.fromWei(eth.getBalance(eth.accounts[1]), "ether")
1
> web3.fromWei(eth.getBalance(instance.address), "ether")
0
```

Now the Faucet is broke.

### Transaction generated by a method invocation
What's inside the transaction generated by the invocation of `sendWei()`?

```javascript
> eth.getTransaction(transaction)
{
  blockHash: "0x71d7d48231240c50b3c4661c31f456968cf15233adc5e66e0850adbf050a4ea7",
  blockNumber: 28,
  from: "0x8b52f87a9dc74c90d31ca5596464db452bb0b55a",
  gas: 90000,
  gasPrice: 1000000000,
  hash: "0x594ae7ab20cee6b54eb2b998b2535876149fe66fa342b92dedbb948b045f329e",
  input: "0x148f2e5e000000000000000000000000addd74744dc8e1f03955398769b1ace793960141",
  nonce: 1,
  r: "0x5598c82c7b13418f6eeed647f2f7b2bc167c18bcaedc667d249a906063b01fb0",
  s: "0x36460198cf2c91fb0edd2190fc841edd36495e2253ded6f5e27da6e011efec1d",
  to: "0xf913dbde31dd9b30e4479381a249c1c6019042dc",
  transactionIndex: 0,
  v: "0xea",
  value: 0
}
```

* `to` is the faucet address:

```javascript
> eth.getTransaction(transaction).to == instance.address
true
```

* `gas` and `gasprice` have been populated with an estimation of the needed gas and the current gas rate; it's an attempt, and it may fail;

* `nonce` is the usual incremental transaction counter, per account;

* `input` contains a reference of the invoked method and its parameter type, plus the parameter value, all packed in 32 bytes:

```javascript
> var value = web3.sha3("sendWei(address)").substring(0, 10) + "000000000000000000000000" + eth.accounts[1].replace("0x", "")
undefined
> value == eth.getTransaction(transaction).input
true
```

We could have obtained the same result by directly sending an artfully crafted transaction:

```javascript
> eth.sendTransaction({
  from: eth.accounts[0],
  to: instance.address,
  data: value,
  gas: 90000,
  gasPrice: eth.gasPrice });
```

## Failing method invocation

What if we call `sendWei()` again? It should fail, since the faucet is broke. But given that the call is asynchronous, it won't be immediate to understand it failed:


```javascript
> var transaction2 = instance.sendWei(eth.accounts[1], {from: eth.accounts[0]})
undefined
> miner.start(1)
null
> txpool.status.pending
0
> miner.stop()
null
> eth.getTransaction(transaction2)
{
  blockHash: "0xb95e3c72ed37b8ce47d799ecde0bd6d521df777322199c873ccf596ac53a60c5",
  blockNumber: 31,
  from: "0x8b52f87a9dc74c90d31ca5596464db452bb0b55a",
  gas: 90000,
  gasPrice: 1000000000,
  hash: "0xdfc92211d9651b3c5661848b8f63ff0790e1899c29b16f58ff1b04deca0d51cd",
  input: "0x148f2e5e000000000000000000000000addd74744dc8e1f03955398769b1ace793960141",
  nonce: 2,
  r: "0x1044297b2e7d7c8c7f017cf7156b9e1408f5410525659980ebe679370aed0248",
  s: "0x3b6a05fea162bb14f2b9bb659730bb161061dfac7d81faca6c8c64453b046144",
  to: "0xf913dbde31dd9b30e4479381a249c1c6019042dc",
  transactionIndex: 0,
  v: "0xea",
  value: 0
}
```

There's nothing in the transaction data that could help us understand if the method invocation succeded or failed. Let's examine the transaction receipts:

```javascript
> eth.getTransactionReceipt(transaction)
{
  blockHash: "0x71d7d48231240c50b3c4661c31f456968cf15233adc5e66e0850adbf050a4ea7",
  blockNumber: 28,
  contractAddress: null,
  cumulativeGasUsed: 55618,
  from: "0x8b52f87a9dc74c90d31ca5596464db452bb0b55a",
  gasUsed: 55618,
  logs: [],
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  status: "0x1",
  to: "0xf913dbde31dd9b30e4479381a249c1c6019042dc",
  transactionHash: "0x594ae7ab20cee6b54eb2b998b2535876149fe66fa342b92dedbb948b045f329e",
  transactionIndex: 0
}
> eth.getTransactionReceipt(transaction2)
{
  blockHash: "0xb95e3c72ed37b8ce47d799ecde0bd6d521df777322199c873ccf596ac53a60c5",
  blockNumber: 31,
  contractAddress: null,
  cumulativeGasUsed: 30620,
  from: "0x8b52f87a9dc74c90d31ca5596464db452bb0b55a",
  gasUsed: 30620,
  logs: [],
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  status: "0x0",
  to: "0xf913dbde31dd9b30e4479381a249c1c6019042dc",
  transactionHash: "0xdfc92211d9651b3c5661848b8f63ff0790e1899c29b16f58ff1b04deca0d51cd",
  transactionIndex: 0
}
```

The `status` is different:

```javascript
> eth.getTransactionReceipt(transaction).status
"0x1"
> eth.getTransactionReceipt(transaction2).status
"0x0"
```


The status `0x0` means that the transaction was not accepted and was rolled back.

Notice that despite the fact that the second transaction was rollbacked:

* it has been included in a block anyway:

```javascript
> eth.getBlock(eth.getTransaction(transaction2).blockHash)
{
  difficulty: 131072,
  extraData: "0xd883010815846765746888676f312e31312e34856c696e7578",
  gasLimit: 5153558,
  gasUsed: 30620,
  hash: "0xb95e3c72ed37b8ce47d799ecde0bd6d521df777322199c873ccf596ac53a60c5",
  logsBloom: "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
  miner: "0x8b52f87a9dc74c90d31ca5596464db452bb0b55a",
  mixHash: "0xe0e613f6b8e1c389922450df3f25a8500bfcb10a990dc634fcb5af821c8c9d38",
  nonce: "0x51c1c7c36c0911f2",
  number: 31,
  parentHash: "0x872dd5b06cde0b43da45c9ca2d1d8ddb550f85fd1c2f3ba1b86e6e89a84f33e8",
  receiptsRoot: "0x80215438af2fabb470901b09060af0c5b5682ebbf5b4a9d3734515350d1be920",
  sha3Uncles: "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
  size: 678,
  stateRoot: "0x7837969ac8afec9e10e4a0e6d8ab77e81e5234f27ddb66d7b161dcb4cd7998ac",
  timestamp: 1560151307,
  totalDifficulty: 4079296,
  transactions: ["0xdfc92211d9651b3c5661848b8f63ff0790e1899c29b16f58ff1b04deca0d51cd"],
  transactionsRoot: "0xebfd18b7bf32ca23af01ffbcc3ac0b49f7d4a491b07d19e1ebe08f9ed40e3153",
  uncles: []
}
> eth.getBlock(eth.getTransaction(transaction2).blockHash).transactions[0] == transaction2
true
```

* it costed money

The question is: who is paying this cost? If we check the balance of `coinbase`, it seems no one paied. But this is only because coinbase spent the gas for paying the miner, but it also is the miner.

Let's top up the faucet using an account different from the one that will mine the block:

## Topping up the faucet

```javascript
> eth.getBalance(eth.accounts[1])
1000000000000000000
> web3.fromWei(eth.getBalance(eth.accounts[1]), "ether")
1
> personal.unlockAccount(eth.accounts[1])
Unlock account 0xaddd74744dc8e1f03955398769b1ace793960141
Passphrase: 
true
> var transaction3 = eth.sendTransaction({from: eth.accounts[1], to: instance.address, value: web3.toWei(0.5, "ether")})
undefined
> transaction3
"0x8bac717bd15ee47afaebf0680eb170ae63815cddc52540d5bcb96fa33f1c0190"
> miner.start(1)
null
> txpool.status.pending
0
> miner.stop()
null
> web3.fromWei(eth.getBalance(instance.address), "ether")
0.5
> web3.fromWei(eth.getBalance(eth.accounts[1]), "ether")
0.49997896
> 
```

So, account 1 sent `0.5` ether, but actually spent a bit more. It makes sense.<br/>
The transaction costed:

```javascript
> eth.getTransaction(transaction3).gas * eth.getTransaction(transaction3).gasPrice
90000000000000
```

### Invoking a method manually forging the transaction
So, after all it seems that for the EVM there's not so much difference between invoking a method and receiving a transaction.<br/>
Top up the faucet:

```javascript
> eth.sendTransaction({from: eth.coinbase, to: instance.address, value: web3.toWei(15, "ether")})
"0x42e5b26b83ec80e99bdd3995680a047a88911b13e27d70c956b58b832db1af31"
> web3.fromWei(eth.getBalance(instance.address), "ether")
15.5
```

Now, let's try to use the faucet never directly invoking the method, but manually forging an artfully crafted transaction, like anticipated before. We need a representation of the method to invoke. `sendWei` is a function:

```javascript
> instance.sendWei
function()
```

We can get a representation of its invocation, including the parameter:
```javascript
> instance.sendWei.getData(eth.accounts[1])
"0x148f2e5e000000000000000000000000addd74744dc8e1f03955398769b1ace793960141"
```

Actually, this is exactly the number we found in the previous transaction:

```javascript
> eth.getTransaction(transaction2).input
"0x148f2e5e000000000000000000000000addd74744dc8e1f03955398769b1ace793960141"
```

Let's use it for the transaction field `data:

```javascript
> eth.sendTransaction({from: eth.coinbase, data: instance.sendWei.getData(eth.accounts[1]), to: instance.address})
"0x74f058112890ba804ff37d290db592ba192c3b8350200613719f8a5ba5b8b967"
> web3.fromWei(eth.getBalance(instance.address), "ether")
14.5
```

It's also possible to specify the gas price and the maximum amount of gas we are willing to spend:

```javascript
> eth.sendTransaction({from: eth.coinbase, data: instance.sendWei.getData(eth.accounts[1]), to: instance.address, gas:190000, gasPrice: eth.gasPrice * 2})
"0x258f3141c486dce1f67ea47f12d2f4138c71e51c49f51d32bb73cd00d8c01005"
> web3.fromWei(eth.getBalance(instance.address), "ether")
13.5
```



[Deploying a faucet](faucet.md)
