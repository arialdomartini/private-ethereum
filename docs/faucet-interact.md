[Deploying a faucet](faucet.md)

# Interacting with the faucet contract

## Invoking `getBalance()`
Let's start by invoking `getBalance()`. It is an idempotent operation that will not cost us any gas:


```javascript
> instance.getBalance()
1000000000000000000
```

Since the implementation of `getBalance()` is 

```solidity
function getBalance() public view returns (uint) {
    return address(this).balance;
}
```

the returned value must be the same of `eth.getBalance(address)`:

```javascript
> instance.getBalance()
1000000000000000000
> eth.getBalance(instance.address)
1000000000000000000
```

Surprisingly:

```javascript
> eth.getBalance(instance.address) == instance.getBalance()
false
```

How could it be? It sounds like a type conversion issue, since:

```javascript
> eth.getBalance(instance.address) + 0 == instance.getBalance() + 0
true
```

The real reason is another one: both `instance.getBalance()` and `eth.getBalance()` return a `BigNumber`, since [Javascript cannot handle the large numbers needed by Ethereum](https://github.com/ethereum/wiki/wiki/JavaScript-API#a-note-on-big-numbers-in-web3js):

```javascript
> typeof instance.getBalance()
"object"
> new BigNumber(instance.getBalance())
1000000000000000000
```

So, if we need to compare the 2 balances, we must use:

```javascript
> new BigNumber(eth.getBalance(instance.address)).equals(new BigNumber(instance.getBalance()))
true
```

## Invoking methods
In general, there are 2 very different ways to invoke a method:

* with a local call, by directly invoking the method or running `someMethod.call()`;
* through a transaction.

The difference is particularly important for methods that modify the contract state.

### Local calls
Local calls are read-only: they cannot change the state of the contract instance. They are like a dry-run execution.

They don't consume any Ether.  Since they are not broadcasted to the network, they are executed synchronously.

When a method is invoked as a local call, the parameters are the ones specified by the signature in the Solidity source code

### Invocation through a transaction
On the contrary, invokations through a transactions are broadcast to the network, processed by one miner and, if valid, included in a block.<br/>
For this reason they are executed asynchronously, and the immediate return value is not the function's result but a transaction hash.

The parameters are the ones specified in the signature of the Solidity source code, plus a Transaction Parameter Object

## Using the faucet to send money to an account

```javascript
> eth.accounts
["0x8b52f87a9dc74c90d31ca5596464db452bb0b55a", "0xaddd74744dc8e1f03955398769b1ace793960141"]
> web3.fromWei(eth.getBalance(eth.accounts[0]), "ether")
53
> web3.fromWei(eth.getBalance(eth.accounts[1]), "ether")
0
```

Account 1 is broke. Let it ask for some money, invoking the method `withdrawWei()` through a transaction:

```javascript
> instance.withdrawWei({from: eth.accounts[1]})
Error: insufficient funds for gas * price + value
    at web3.js:3143:20
    at web3.js:6347:15
    at web3.js:5081:36
    at web3.js:4137:16
    at apply (<native code>)
    at web3.js:4223:16
    at <anonymous>:1:1
```

This makes sense: in order to emit a transaction, some gas must be spent.<br/>
Let's use the account 0 to send money to account 1:

```javascript
> var transaction = instance.sendWei(eth.accounts[1], {from: eth.accounts[0]})
undefined
> transaction
"0x594ae7ab20cee6b54eb2b998b2535876149fe66fa342b92dedbb948b045f329e"
> txpool.status.pending
1
> miner.start()
null
> miner.stop()
null
> txpool.status.pending
0
> web3.fromWei(eth.getBalance(eth.accounts[1]), "ether")
1
> web3.fromWei(eth.getBalance(instance.address), "ether")
0
```

Now the Faucet is broke.

### Transaction generated by a method invocation
What's inside the transaction generated by the invocation of `sendWei()`?

```javascript
> eth.getTransaction(transaction)
{
  blockHash: "0x71d7d48231240c50b3c4661c31f456968cf15233adc5e66e0850adbf050a4ea7",
  blockNumber: 28,
  from: "0x8b52f87a9dc74c90d31ca5596464db452bb0b55a",
  gas: 90000,
  gasPrice: 1000000000,
  hash: "0x594ae7ab20cee6b54eb2b998b2535876149fe66fa342b92dedbb948b045f329e",
  input: "0x148f2e5e000000000000000000000000addd74744dc8e1f03955398769b1ace793960141",
  nonce: 1,
  r: "0x5598c82c7b13418f6eeed647f2f7b2bc167c18bcaedc667d249a906063b01fb0",
  s: "0x36460198cf2c91fb0edd2190fc841edd36495e2253ded6f5e27da6e011efec1d",
  to: "0xf913dbde31dd9b30e4479381a249c1c6019042dc",
  transactionIndex: 0,
  v: "0xea",
  value: 0
}
```

* `to` is the faucet address:

```javascript
> eth.getTransaction(transaction).to == instance.address
true
```

* `gas` and `gasprice` have been populated with an estimation of the needed gas and the current gas rate; it's an attempt, and it may fail;

* `nonce` is the usual incremental transaction counter, per account;

* `input` contains a reference of the invoked method and its parameter type, plus the parameter value, all packed in 32 bytes:

```javascript
> var value = web3.sha3("sendWei(address)").substring(0, 10) + "000000000000000000000000" + eth.accounts[1].replace("0x", "")
undefined
> value == eth.getTransaction(transaction).input
true
```


[Deploying a faucet](faucet.md)
